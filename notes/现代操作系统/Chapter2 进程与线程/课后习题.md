# 课后习题

- 1、图2-2中给出了三个进程状态（，在理论上，三个状态可以有六种转换，每个状态两个。但是，图中只给出了四种转换。有没有可能发生其他两种转换中的一个或两个？

![图2-2](/images/os/mos/2-2.png)

> 答：就绪->阻塞。阻塞是因为外界原因(比如等待资源)挂起进程，就绪状态下的线程并没有占到CPU资源，因此不会执行任何操作，不会因为任何操作直接进入阻塞。 阻塞->运行。理论上可行，比如一个进程在完成了I/O，阻塞可以结束，此时可以直接进入CPU执行。但是进程需要通过调度程序控制执行顺序，进程调度器会根据进程优先级安排执行顺序，所以必须经过“就绪”这一准备状态。

- 2、假设要设计一种先进的计算机体系结构，它使用硬件而不是中断来完成进程切换。CPU需要哪些信息？请描述用硬件完成进程切换的工作过程。
> 答：用一个寄存器保存指向当前进程的进程表项的指针，进程I/O结束后，CPU把当前的机器状态保存到这个进程表项，然后CPU再通过中断设备的中断向量获取指向另一个进程表项的指针，然后就可以启动这个进程。

- 3、在所有当代计算机中，至少有部分中断处理程序是用汇编语言编写的。为什么？
> 答：因为通常来说高级语言是无法直接描述底层操作的，比如保存寄存器和设置堆栈指针等，所以这些操作需要通过汇编语言来完成。

**具体中断过程？**  


- 4.当中断或系统调用把控制转给操作系统时，通常将内核堆栈和被中断进程的运行堆栈分离。为什么？
> 答：如果不分离，内核堆栈就要保存用户进程的堆栈(中断栈)信息，如果用户进程的堆栈过大，可能会让内核堆栈溢出导致系统崩溃。  

**Linux有进程栈，线程栈，内核栈，中断栈**


5.多个作业能够并行运行，比它们顺序执行完成的要快。假设有两个作业同时开始执行，每个需要10分钟的CPU时间。如果顺序执行，那么最后一个作业需要多长时间可以完成？如果并行执行又需要多长时间？假设I/O等待占50%。

> 答：CPU利用率计算公式(P53)：CPU利用率 = 1 - p<sup>n</sup>  
*p表示进程等待I/O操作的时间与其停留在内存中时间的比，n表示多道程序设计的道数，即进程数。*   
由题目可知，p = 0.5，n = 2； 
顺序执行： T = (10 * 2) / 0.5 = 40min  
并行执行： T' = T / (1 - 0.5<sup>2</sup>) = 40 / 0.75 = 26.7min 


- 6.在本章中说明的图2-11a的模式不适合用于使用*内存高速缓存的文件服务器*。为什么不适合？每个进程可以有自己的高速缓存吗？  
![图2-11](/images/os/mos/2-11.png)

> 答：如果每个进程都有自己的高速缓存，其他进程在更新一个共享数据时，需要同步到所有持有这个数据的进程高速缓存，如果不这样做，每个进程在使用缓存数据时都要从磁盘去验证一下这是不是最新的，以避免读取脏数据，而这样做就另缓存失去意义了。

7.如果创建一个多线程进程，若子进程得到全部父进程线程的副本，会出现问题。假如原有线程之一正在等待键盘输入，现在则成为两个线程在等待键盘输入，每个进程有一个。在单线程进程中也会发生这种问题吗？

> 答：不会。如果单线程进程处于阻塞状态，它就无法fork子进程。

8.在图2-8中，给出了一个多线程Web服务器。如果读取文件的惟一途径是正常的阻塞read系统调用，那么Web服务器应该使用用户级线程还是内核级线程？为什么？
![图2-8](/images/os/mos/2-8.png)

> 答：内核级线程。如果使用用户级线程，一个线程因为向内核请求read系统调用读取页面会导致线程所在的整个进程阻塞，这个进程的其他线程也会无法工作，这样就会彻底失去多线程进程的意义。而内核级线程的阻塞不会影响其他线程。

9.在本章中，我们介绍了多线程Web服务器，说明它比单线程服务器和有限状态机服务器更好的原因。存在单线程服务器更好一些的情形吗？请给出一个例子。(P56)

| 模型 | 特性 |
| :--: | :---: | 
| 多线程服务器| 并行性，阻塞系统调用 |
|单线程服务器| 无并行性，阻塞系统调用 |
|有限状态机| 并行性，非阻塞系统调用，中断 |

> 答：  
1、如果程序是单纯的CPU密集型，那么单线程就可以处理，无需使用多线程来增加无谓的复杂度。而Web服务器的应用场景往往不是单纯的CPU密集型，还会涉及很多I/O操作。
2、多线程服务器可以同时执行多个任务，比单线程服务器的CPU使用率高，效率也更高。
3、有限状态机通过非阻塞的系统调用处理请求，异步处理任务，这样就需要保存每一个请求的状态，处理完成后根据请求的状态发出不同的响应或中断，性能比单纯的多线程服务器好，但是设计的复杂度也会比多线程高很多。

10.在图2-12中寄存器集合按每个线程中的内容列出而不是按每个进程中的内容列出。为什么？毕竟机器只有一套寄存器。
![图2-12](/images/os/mos/2-12.png)

> 答：因为进程是计算机资源管理的基本单位，而线程才是真正被调度执行的实体。同一个进程中的多个线程都有自己的独立堆栈，要保证一个进程中的所有线程能够互不打扰地执行，必须单独保存每个线程私有的堆栈内容。

11.为什么线程要通过调用thread_yield自愿放弃CPU？毕竟，由于没有周期性的时钟中断，线程可以不交回CPU。
> 答：线程可以分为抢占式和非抢占式。

| 类型 | 特性 |
| -- | -- |
| 抢占式 |  |  ？
| 非抢占式 | |  ？

> 如果线程不交回CPU，或直到挂起或结束才交回CPU，就会导致线程串行执行。试想在文档进程中，A线程负责计算页码和整理每页的内容，B线程负责5分钟保存一个草稿，如果在B线程要去执行任务时A线程没有完成，那么B就必须等待A自己挂起或者结束，因为A不会自己让出CPU，这样就会导致B的任务无法保证B能够在5分钟的时间间隔保存草稿副本。而且，一个用户进程中的多线程往往是相互协作的，具体如何执行取决于程序员。

12.线程可以被时钟中断抢占吗？如果可以，什么情形下可以？如果不可以，为什么不可以？
> 内核级线程可以被时钟中断直接抢占。用户级线程不能直接被时钟中断抢占，但是当其所在进程被时钟中断抢占时线程也会被阻塞。

13.在本习题中，要求对使用单线程文件服务器和多线程文件服务器读取文件进行比较。假设所需要的数据都在块高速缓存中，花费15ms获得工作请求，分派工作，并处理其余必要工作。如果在三分之一时间时，需要一个磁盘操作，要另外花费75ms，此时该线程进入睡眠。在单线程情形下服务器每秒钟可以处理多少个请求？如果是多线程呢？

> 答：单线程在缓存命中情况下需要15ms，未命中情况下需要90ms。  
？？？

14.在用户空间实现线程，其最大的优点是什么？最大的缺点是什么？
> 答：最大的优点是没有上下文切换，速度很快。最大的缺点是没有中断机制，当一个线程请求系统调用时陷入内核，整个进程都被阻塞，其他所有在这个进程中的线程也都被阻塞。

15.在图2-15中创建线程和线程打印消息是随机交织在一起的。有没有方法可以严格按照以下次序运行：创建线程1，线程1打印消息，线程1结束；创建线程2，线程2打印消息，线程2结束；以此类推。如果有，是什么方法，如果没有请解释原因。

> 答： pthread_join

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUMBER_OF_THREADS 10

void *print_hello_world(void* tid){
    printf("print thread %d\n", tid);
    pthread_exit(NULL);
}

int main(int args, char **argv) {
    pthread_t threads[NUMBER_OF_THREADS];
    int status, i;
    for(i = 0; i < NUMBER_OF_THREADS; i++){
        printf("Main here, create thread %d\n", i);
        status = pthread_create(&threads[i], NULL, print_hello_world, (void*)i);
        if(status != 0){
            printf("CREATE THREAD FAILED! error code %d\n", status);
            exit(-1);
        }
        //增加这行，阻塞等待当前创建的线程执行结束再继续往下
        pthread_join(threads[i], NULL);
    }
    exit(NULL);
}
```
```
Main here, create thread 0
print thread 0
Main here, create thread 1
print thread 1
Main here, create thread 2
print thread 2
Main here, create thread 3
print thread 3
Main here, create thread 4
print thread 4
Main here, create thread 5
print thread 5
Main here, create thread 6
print thread 6
Main here, create thread 7
print thread 7
Main here, create thread 8
print thread 8
Main here, create thread 9
print thread 9
```

16.在讨论线程中的全局变量时，曾使用过程create_global将存储分配给指向变量的指针，而不是变量自身。这是必需的，还是由于该过程也需要使用这些值？
> 答：这是必须的。因为你无法知道这个变量的类型，如果直接使用值类型，那么set_global方法和read_global方法的参数又如何确定。

17.考虑线程全部在用户空间实现的一个系统，其中运行时系统每秒钟得到一个时钟中断。假设在该运行时系统中，当某个线程正在执行时发生一个时钟中断，此时会出现什么问题？你有什么解决该问题的建议吗？
> 答：此时线程会因为中断阻塞，即使它的任务只是运行了一半。可以在用户线程调度程序增加一个标示位，当系统中断发生时标记这个标示位，线程不用马上响应，当线程处理完自己的任务后或者指定每个一段时间，去检查这个标记位，如果发现被系统中断标记过了，那么就响应这次中断，然后把标记清零。

18.假设一个操作系统中不存在类似于select的系统调用来提前了解在从文件、管道或设备中读取时是否安全，不过该操作系统确实允许设置报警时钟，以便中断阻塞的系统调用。在上述条件下，是否有可能在用户空间中实现一个线程包？请加以讨论。
> 答：可以实现。用户线程每次请求系统调用之前先设置时钟定时器，可以中断阻塞，然后清空定时器。但是这种设计完全依赖于定时器，如果定时器出问题，那么整个系统都将无法使用。

19.在2.3.4节中所讨论的优先级反转问题是否可能在用户级线程中发生？为什么？  
(考虑一台计算机有两个进程，H优先级较高，L优先级较低。调度规则规定，只要H处于就绪态它就可以运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行（例如，一条I/O操作结束）。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远忙等待下去。这种情况有时被称作优先级反转问题（priority inversion problem）。)
> 答：不会发生。处于同一进程中的线程，由于内核不知道线程的存在，当一个线程阻塞时整个进程都阻塞了，所以不会有其他线程“抢占”执行的情况。处于不同进程中的线程，无从比较线程优先级，只会是进程优先级反转，导致线程阻塞。

20.在2.3.4节中，描述了一种有高优先级进程H和低优先级进程L的情况，导致了H陷入死循环。若采用轮转调度算法而不是优先级调度算法，还会发生同样问题吗？请给予讨论。
> 答：不会发生。如果轮转调度，那么进程L早晚都可以离开临界区(释放锁)。

21.在使用线程的系统中，若使用用户级线程，是每个线程一个堆栈还是每个进程一个堆栈？如果使用内核级线程情况又如何呢？请给予解释。
> 答：不管是用户级还是内核级，线程都有自己的独立堆栈用来保存私有变量，方法出口等信息。

22.在开发计算机时，通常首先用一个程序模拟，一次运行一条指令，甚至多处理器也严格按此模拟。在类似于这种没有同时事件发生的情形下，会出现竞争条件吗？
> 答：会。多个程序同时运行，假设A和B同时访问一个共享变量S，同时要操作这个共享变量，此时就出现竞争条件。

23.两个进程在一个共享存储器多处理器（即两个CPU）上运行，当它们要共享一个公共内存时，图2-23所示的采用变量turn的忙等待解决方案还有效吗？
![图2-23](/images/os/mos/2-23.png)
> 答：有效，依然是忙等。

24.在进程调度是抢占式的情形下，图2-24中展示的互斥问题的Peterson解法能正常工作吗？如果是非抢占式的情况呢？
![图2-24](/images/os/mos/2-24.png)
答：能正常工作。非抢占式无法工作。？

25.给出一个可以屏蔽中断的操作系统如何实现信号量的框架。



26.请说明计数信号量（即可以保持一个任意值的信号量）如何仅通过二元信号量和普通机器指令实现。


