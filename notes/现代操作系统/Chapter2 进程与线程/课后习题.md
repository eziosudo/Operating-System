# 课后习题

- 1、图2-2中给出了三个进程状态（，在理论上，三个状态可以有六种转换，每个状态两个。但是，图中只给出了四种转换。有没有可能发生其他两种转换中的一个或两个？

![图2-2](/images/os/mos/2-2.png)

> 答：就绪->阻塞。阻塞是因为外界原因(比如等待资源)挂起进程，就绪状态下的线程并没有占到CPU资源，因此不会执行任何操作，不会因为任何操作直接进入阻塞。 阻塞->运行。理论上可行，比如一个进程在完成了I/O，阻塞可以结束，此时可以直接进入CPU执行。但是进程需要通过调度程序控制执行顺序，所以必须经过“就绪”这一准备状态。

- 2、假设要设计一种先进的计算机体系结构，它使用硬件而不是中断来完成进程切换。CPU需要哪些信息？请描述用硬件完成进程切换的工作过程。
> 答：用一个寄存器保存指向当前进程的进程表项的指针，进程I/O结束后，CPU把当前的机器状态保存到这个进程表项，然后CPU再通过中断设备的中断向量获取指向另一个进程表项的指针，然后就可以启动这个进程。

- 3、在所有当代计算机中，至少有部分中断处理程序是用汇编语言编写的。为什么？
> 答：因为通常来说高级语言是无法直接描述底层操作的，比如保存寄存器和设置堆栈指针等，所以这些操作需要通过汇编语言来完成。

**具体中断过程？**  


- 4.当中断或系统调用把控制转给操作系统时，通常将内核堆栈和被中断进程的运行堆栈分离。为什么？
> 答：如果不分离，内核堆栈就要保存用户进程的堆栈(中断栈)信息，如果用户进程的堆栈过大，可能会让内核堆栈溢出导致系统崩溃。  

**Linux有进程栈，线程栈，内核栈，中断栈**


5.多个作业能够并行运行，比它们顺序执行完成的要快。假设有两个作业同时开始执行，每个需要10分钟的CPU时间。如果顺序执行，那么最后一个作业需要多长时间可以完成？如果并行执行又需要多长时间？假设I/O等待占50%。

> 答：CPU利用率计算公式(P53)：CPU利用率 = 1 - p<sup>n</sup>  
*p表示进程等待I/O操作的时间与其停留在内存中时间的比，n表示多道程序设计的道数，即进程数。*   
由题目可知，p = 0.5，n = 2； 
顺序执行： T = (10 * 2) / 0.5 = 40min  
并行执行： T' = T / (1 - 0.5<sup>2</sup>) = 40 / 0.75 = 26.7min 


- 6.在本章中说明的图2-11a的模式不适合用于使用*内存高速缓存的文件服务器*。为什么不适合？每个进程可以有自己的高速缓存吗？
![图2-11](/images/os/mos/2-11.png)

> 答：如果每个进程都有自己的高速缓存，其他进程在更新一个共享数据时，需要同步到所有持有这个数据的进程高速缓存，如果不这样做，每个进程在使用缓存数据时都要从磁盘去验证一下这是不是最新的，以避免读取脏数据，而这样做就另缓存失去意义了。

7.如果创建一个多线程进程，若子进程得到全部父进程线程的副本，会出现问题。假如原有线程之一正在等待键盘输入，现在则成为两个线程在等待键盘输入，每个进程有一个。在单线程进程中也会发生这种问题吗？

> 答：不会。如果单线程进程处于阻塞状态，它就无法fork子进程。

8.在图2-8中，给出了一个多线程Web服务器。如果读取文件的惟一途径是正常的阻塞read系统调用，那么Web服务器应该使用用户级线程还是内核级线程？为什么？
![图2-8](/images/os/mos/2-8.png)

> 答：内核级线程。如果使用用户级线程，一个线程因为向内核请求read系统调用读取页面会导致线程所在的整个进程阻塞，这个进程的其他线程也会无法工作，这样就会彻底失去多线程进程的意义。而内核级线程的阻塞不会影响其他线程。

9.在本章中，我们介绍了多线程Web服务器，说明它比单线程服务器和有限状态机服务器更好的原因。存在单线程服务器更好一些的情形吗？请给出一个例子。

> 答：

10.在图2-12中寄存器集合按每个线程中的内容列出而不是按每个进程中的内容列出。为什么？毕竟机器只有一套寄存器。

11.为什么线程要通过调用thread_yield自愿放弃CPU？毕竟，由于没有周期性的时钟中断，线程可以不交回CPU。

12.线程可以被时钟中断抢占吗？如果可以，什么情形下可以？如果不可以，为什么不可以？

13.在本习题中，要求对使用单线程文件服务器和多线程文件服务器读取文件进行比较。假设所需要的数据都在块高速缓存中，花费15ms获得工作请求，分派工作，并处理其余必要工作。如果在三分之一时间时，需要一个磁盘操作，要另外花费75ms，此时该线程进入睡眠。“在单线程情形下服务器每秒钟可以处理多少个请求？如果是多线程呢？
